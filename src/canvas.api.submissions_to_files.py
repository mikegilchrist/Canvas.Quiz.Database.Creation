#!/usr/bin/env python3
# ============================================================================
# Script:       submissions_to_files.py
# Version:      1.0.0
# Date:         2026-02-20
# Purpose:      Download Canvas assignment submissions (files, rubric scores,
#               comments, submission history) -- the same data visible in
#               SpeedGrader.
#
# Usage:        submissions_to_files.py COURSE_ID [ASSIGNMENT_ID] --base-url URL
#                   [--token TOKEN | --token-file FILE]
#                   [--group NAME] [--outdir DIR]
#                   [--anonymize] [--update]
#                   [--dry-run] [--verbose] [--help]
#
# Input:        Canvas API token + course_id (+ optional assignment_id)
# Output:       Per-assignment directories with JSON metadata and student files
#
# Options:
#   --base-url URL          Canvas instance URL (required)
#   --token TOKEN           Inline API token
#   --token-file FILE       Path to file containing API token
#   --group NAME            Filter by assignment group name (case-insensitive)
#   --outdir DIR            Output directory (default: output/Assignments)
#   --anonymize             Replace student PII with anonymous identifiers
#   -u, --update            Skip assignments whose output directory exists
#   -n, --dry-run           Show what would be done without making changes
#   -v, --verbose           Show detailed output
#   -h, --help              Show this help message
#
# Requirements:
#   - Python 3.7+
#   - Canvas API token with instructor/TA access to the course
#
# Session:      Canvas API Assignments
# AI Model:     Claude Opus 4.6
# Attribution:  Generated by Michael Gilchrist in collaboration with
#               ClaudeAI Opus 4.6
# ============================================================================

import argparse
import json
import os
import sys

from canvas_api import (
    get_assignment,
    get_assignment_groups,
    get_assignment_submissions,
    get_assignments,
    get_rubric,
)
from canvas_http import http_get_raw
from io_utils import load_profile, read_token, sanitize_for_filename


def student_slug(submission, index, anonymize):
    """Build a directory name for one student's submission.

    Normal:    LastName.FirstName_canvas-id
    Anonymize: Student_01
    """
    if anonymize:
        return f"Student_{index:02d}"
    user = submission.get("user", {})
    name = user.get("sortable_name") or user.get("name") or "Unknown"
    uid = user.get("id", "")
    slug = sanitize_for_filename(name, max_len=40)
    return f"{slug}_{uid}"


# ---- Anonymization ----

def anonymize_submission(sub, student_label):
    """Return a copy of the submission dict with PII removed."""
    anon = dict(sub)
    # Remove user object
    anon.pop("user", None)
    anon.pop("group", None)
    anon["student_label"] = student_label
    # Scrub comments author info
    if "submission_comments" in anon:
        clean_comments = []
        for c in anon["submission_comments"]:
            cc = dict(c)
            cc.pop("author", None)
            cc.pop("author_id", None)
            cc.pop("author_name", None)
            clean_comments.append(cc)
        anon["submission_comments"] = clean_comments
    return anon


# ---- Core download logic ----

def download_one_assignment(base_url, token, course_id, assignment,
                            outdir, anonymize, update, verbose):
    """Download submissions for a single assignment.
    Returns (assignment_dir, status_str) where status_str is one of:
    None (success), "skip" (--update), or an error message.
    """
    aid = assignment["id"]
    title = assignment.get("name", "(untitled)")
    slug = sanitize_for_filename(title)
    assignment_dir = os.path.join(outdir, slug)

    # --update: skip if directory already exists
    if update and os.path.isdir(assignment_dir):
        return assignment_dir, "skip"

    try:
        # Fetch submissions
        submissions = get_assignment_submissions(
            base_url, token, course_id, aid, verbose=verbose)

        # Filter to only submitted students
        submitted = [s for s in submissions
                     if s.get("workflow_state") != "unsubmitted"
                     and s.get("submitted_at") is not None]

        if not submitted:
            if verbose:
                print(f"  [INFO] No submissions for assignment {aid}")
            # Still create the directory with assignment metadata
            os.makedirs(assignment_dir, exist_ok=True)
            _write_json(os.path.join(assignment_dir, "assignment.json"),
                        assignment)
            return assignment_dir, None

        os.makedirs(assignment_dir, exist_ok=True)

        # Write assignment metadata
        _write_json(os.path.join(assignment_dir, "assignment.json"),
                    assignment)

        # Write rubric definition if present
        rubric_settings = assignment.get("rubric_settings")
        rubric = assignment.get("rubric")
        if rubric:
            # Rubric is inline on the assignment object
            rubric_data = {
                "rubric_settings": rubric_settings,
                "criteria": rubric,
            }
            _write_json(os.path.join(assignment_dir, "rubric.json"),
                        rubric_data)
        elif assignment.get("rubric_settings", {}).get("id"):
            # Rubric not inline -- fetch separately
            rubric_id = assignment["rubric_settings"]["id"]
            try:
                rubric_data = get_rubric(base_url, token, course_id,
                                         rubric_id, verbose=verbose)
                _write_json(os.path.join(assignment_dir, "rubric.json"),
                            rubric_data)
            except Exception as e:
                if verbose:
                    print(f"  [WARN] Could not fetch rubric {rubric_id}: {e}")

        # Sort by student name for consistent ordering
        submitted.sort(key=lambda s: (
            s.get("user", {}).get("sortable_name", "") or ""))

        # Process each student
        file_count = 0
        for i, sub in enumerate(submitted, 1):
            sdir_name = student_slug(sub, i, anonymize)
            sdir = os.path.join(assignment_dir, sdir_name)
            os.makedirs(sdir, exist_ok=True)

            # Write submission metadata
            if anonymize:
                sub_data = anonymize_submission(sub, f"Student_{i:02d}")
            else:
                sub_data = sub
            _write_json(os.path.join(sdir, "submission.json"), sub_data)

            # Download file attachments
            attachments = sub.get("attachments", [])
            for att in attachments:
                att_url = att.get("url")
                att_name = att.get("filename") or att.get("display_name",
                                                           "file")
                if not att_url:
                    continue
                dest = os.path.join(sdir, att_name)
                # Avoid overwriting if duplicate filenames
                if os.path.exists(dest):
                    base, ext = os.path.splitext(att_name)
                    dest = os.path.join(sdir,
                                        f"{base}_{att['id']}{ext}")
                try:
                    data = http_get_raw(att_url)
                    with open(dest, "wb") as f:
                        f.write(data)
                    file_count += 1
                    if verbose:
                        print(f"    [FILE] {dest} ({len(data)} bytes)")
                except Exception as e:
                    print(f"    [WARN] Failed to download {att_name}: {e}",
                          file=sys.stderr)

        if verbose:
            print(f"  [INFO] {len(submitted)} submissions, "
                  f"{file_count} files downloaded")

        return assignment_dir, None

    except Exception as e:
        return None, str(e)


def _write_json(path, obj):
    """Write a JSON file with consistent formatting."""
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=True, indent=2)


# ---- Group resolution ----

def resolve_group_id(base_url, token, course_id, group_name, verbose=False):
    """Find the assignment group ID matching group_name (case-insensitive).
    Returns (group_id, group_name_canonical) or raises SystemExit.
    """
    groups = get_assignment_groups(base_url, token, course_id, verbose=verbose)
    for g in groups:
        if g.get("name", "").lower() == group_name.lower():
            return g["id"], g["name"]
    names = [g.get("name", "") for g in groups]
    print(f"No assignment group matching '{group_name}'.")
    print(f"Available groups: {', '.join(names)}")
    raise SystemExit(1)


# ---- CLI ----

def main():
    ap = argparse.ArgumentParser(
        description="Download Canvas assignment submissions (files, rubric "
                    "scores, comments).  Pass an ASSIGNMENT_ID for a single "
                    "assignment, or omit it to download all assignments in "
                    "the course.")
    ap.add_argument("course_id", type=int,
                    help="Canvas course ID")
    ap.add_argument("assignment_id", nargs="?", type=int, default=None,
                    help="Canvas assignment ID (omit for batch mode)")

    ap.add_argument("--base-url", default=None,
                    help="Canvas instance URL (or set base_url in "
                         "~/.canvas.api.conf)")
    ap.add_argument("--token", default=None,
                    help="Canvas API token (inline)")
    ap.add_argument("--token-file", default=None,
                    help="Path to token file (or set token_file in "
                         "~/.canvas.api.conf)")

    ap.add_argument("--group", default=None,
                    help="Filter by assignment group name (case-insensitive, "
                         "e.g. --group Homework)")
    ap.add_argument("--outdir",
                    default=os.path.join("output", "Assignments"),
                    help="Output directory (default: output/Assignments)")

    ap.add_argument("--anonymize", action="store_true",
                    help="Replace student PII with anonymous identifiers")
    ap.add_argument("-u", "--update", action="store_true",
                    help="Skip assignments whose output directory exists")

    ap.add_argument("-n", "--dry-run", action="store_true",
                    help="Show what would be done without making changes")
    ap.add_argument("-v", "--verbose", action="store_true",
                    help="Show detailed output")

    args = ap.parse_args()

    profile = load_profile()
    if not args.base_url:
        args.base_url = profile.get("base_url")
    if not args.base_url:
        ap.error("--base-url is required (or set base_url in "
                 "~/.canvas.api.conf)")
    token = read_token(args.token, args.token_file, profile)
    base_url = args.base_url.rstrip("/")

    # Build the list of assignments to process
    if args.assignment_id is not None:
        # Single-assignment mode
        asgn = get_assignment(base_url, token, args.course_id,
                              args.assignment_id, verbose=args.verbose)
        assignment_list = [asgn]
    else:
        # Batch mode
        group_id = None
        if args.group:
            group_id, group_label = resolve_group_id(
                base_url, token, args.course_id, args.group,
                verbose=args.verbose)
            print(f"Filtering by group: {group_label}")

        print(f"Fetching assignments for course {args.course_id}...")
        assignment_list = get_assignments(
            base_url, token, args.course_id,
            assignment_group_id=group_id, verbose=args.verbose)

        # Only published assignments
        assignment_list = [a for a in assignment_list if a.get("published")]
        assignment_list.sort(key=lambda a: a.get("name", ""))

    if not assignment_list:
        print("No assignments matched filters.")
        return

    if len(assignment_list) > 1:
        print(f"Found {len(assignment_list)} assignments to process.\n")

    # Dry-run output
    if args.dry_run:
        for a in assignment_list:
            aid = a.get("id", "?")
            name = a.get("name", "(untitled)")
            slug = sanitize_for_filename(name)
            adir = os.path.join(args.outdir, slug)
            exists = os.path.isdir(adir)
            skip_note = ("  [exists, would skip]"
                         if (args.update and exists) else "")
            print(f"  [DRY RUN] assignment {aid}: {name}{skip_note}")
        return

    # Process each assignment
    ok_count = 0
    skip_count = 0
    fail_count = 0
    total = len(assignment_list)

    for i, a in enumerate(assignment_list, 1):
        aid = a.get("id")
        name = a.get("name", "(untitled)")
        prefix = f"[{i}/{total}] " if total > 1 else ""
        print(f"{prefix}Assignment {aid}: {name}")

        outpath, err = download_one_assignment(
            base_url=base_url,
            token=token,
            course_id=args.course_id,
            assignment=a,
            outdir=args.outdir,
            anonymize=args.anonymize,
            update=args.update,
            verbose=args.verbose,
        )

        if err == "skip":
            print(f"  [SKIP] Already exists: {outpath}")
            skip_count += 1
        elif err:
            print(f"  [FAIL] {err}", file=sys.stderr)
            fail_count += 1
        else:
            print(f"  [OK] {outpath}")
            ok_count += 1

    # Summary for batch mode
    if total > 1:
        parts = [f"{ok_count} downloaded"]
        if skip_count:
            parts.append(f"{skip_count} skipped")
        if fail_count:
            parts.append(f"{fail_count} failed")
        print(f"\nDone: {', '.join(parts)} (of {total} assignments).")


if __name__ == "__main__":
    main()
