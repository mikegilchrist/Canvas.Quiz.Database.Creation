#!/usr/bin/env python3
# ============================================================================
# Script:       list_assignments.py
# Version:      1.0.0
# Date:         2026-02-20
# Purpose:      List all assignments in a Canvas course with ID, group,
#               points, published status, due date, submission type, and title.
#
# Usage:        list_assignments.py COURSE_ID --base-url URL
#                   [--token TOKEN | --token-file FILE]
#                   [--group NAME] [--published-only]
#                   [--verbose] [--help]
#
# Input:        Canvas API token + course_id
# Output:       Tabular assignment listing to stdout
#
# Options:
#   --base-url URL          Canvas instance URL (required)
#   --token TOKEN           Inline API token
#   --token-file FILE       Path to file containing API token
#   --group NAME            Filter by assignment group name (case-insensitive)
#   --published-only        Only show published assignments
#   -v, --verbose           Show detailed output
#   -h, --help              Show this help message
#
# Session:      Canvas API Assignments
# AI Model:     Claude Opus 4.6
# Attribution:  Generated by Michael Gilchrist in collaboration with
#               ClaudeAI Opus 4.6
# ============================================================================

import argparse

from canvas_api import get_assignment_groups, get_assignments
from io_utils import load_profile, read_token


def resolve_group_id(base_url, token, course_id, group_name, verbose=False):
    """Find the assignment group ID matching group_name (case-insensitive).
    Returns (group_id, group_name_canonical) or raises SystemExit.
    """
    groups = get_assignment_groups(base_url, token, course_id, verbose=verbose)
    for g in groups:
        if g.get("name", "").lower() == group_name.lower():
            return g["id"], g["name"]
    names = [g.get("name", "") for g in groups]
    print(f"No assignment group matching '{group_name}'.")
    print(f"Available groups: {', '.join(names)}")
    raise SystemExit(1)


def main():
    ap = argparse.ArgumentParser(
        description="List all assignments in a Canvas course.")
    ap.add_argument("course_id", type=int,
                    help="Canvas course ID")

    ap.add_argument("--base-url", default=None,
                    help="Canvas instance URL (or set base_url in "
                         "~/.canvas.api.conf)")
    ap.add_argument("--token", default=None,
                    help="Canvas API token (inline)")
    ap.add_argument("--token-file", default=None,
                    help="Path to token file (or set token_file in "
                         "~/.canvas.api.conf)")

    ap.add_argument("--group", default=None,
                    help="Filter by assignment group name (case-insensitive)")
    ap.add_argument("--published-only", action="store_true",
                    help="Only show published assignments")
    ap.add_argument("-v", "--verbose", action="store_true",
                    help="Show detailed output")

    args = ap.parse_args()

    profile = load_profile()
    if not args.base_url:
        args.base_url = profile.get("base_url")
    if not args.base_url:
        ap.error("--base-url is required (or set base_url in "
                 "~/.canvas.api.conf)")
    token = read_token(args.token, args.token_file, profile)
    base_url = args.base_url.rstrip("/")

    # Resolve group filter
    group_id = None
    group_label = "All"
    if args.group:
        group_id, group_label = resolve_group_id(
            base_url, token, args.course_id, args.group, verbose=args.verbose)
        if args.verbose:
            print(f"[INFO] Filtering by group: {group_label} (id={group_id})")

    # Build a group-id-to-name map for display
    groups = get_assignment_groups(base_url, token, args.course_id,
                                  verbose=args.verbose)
    group_names = {g["id"]: g.get("name", "") for g in groups}

    if args.verbose:
        print(f"[INFO] Fetching assignments for course {args.course_id}...")

    assignments = get_assignments(base_url, token, args.course_id,
                                  assignment_group_id=group_id,
                                  verbose=args.verbose)

    if args.published_only:
        assignments = [a for a in assignments if a.get("published")]

    # Sort by name for readability
    assignments.sort(key=lambda a: a.get("name", ""))

    if not assignments:
        print("No assignments found.")
        return

    # Print table header
    print(f"{'ID':>8}  {'Group':<16}  {'Pts':>6}  {'Pub':>3}  "
          f"{'Due':<11}  {'Sub Type':<14}  Title")
    print(f"{'---':>8}  {'---':<16}  {'---':>6}  {'---':>3}  "
          f"{'---':<11}  {'---':<14}  ---")

    for a in assignments:
        aid = a.get("id", "")
        name = a.get("name", "(untitled)")
        gname = group_names.get(a.get("assignment_group_id"), "")
        # Truncate group name for column width
        if len(gname) > 16:
            gname = gname[:15] + "."
        published = "yes" if a.get("published") else "no"
        points = a.get("points_possible")
        pts_str = f"{points:g}" if points is not None else "-"
        due = a.get("due_at", "") or ""
        due_str = due[:10] if due else "-"
        sub_types = a.get("submission_types", [])
        sub_str = ",".join(sub_types) if sub_types else "-"
        if len(sub_str) > 14:
            sub_str = sub_str[:13] + "."

        print(f"{aid:>8}  {gname:<16}  {pts_str:>6}  {published:>3}  "
              f"{due_str:<11}  {sub_str:<14}  {name}")

    print(f"\nTotal: {len(assignments)} assignments"
          f" (group: {group_label})")


if __name__ == "__main__":
    main()
