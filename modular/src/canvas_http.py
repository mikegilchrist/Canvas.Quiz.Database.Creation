#!/usr/bin/env python3
#
# Date: 2026-02-19
# Version: 1.1.0
# Purpose: HTTP helpers for Canvas API requests, including pagination.
# Usage: Imported by other modules.
# Input: Canvas base URL and token; endpoint URL.
# Output: Decoded JSON objects (Python dict/list).
# Chat name: Canvas SpeedGrader Archive
# GPT Model: GPT-5.2 Thinking
# Attribution: Generated by Michael Gilchrist in collaboration with ChatGPT.

import json
import urllib.request


def http_get_json(url, token):
    req = urllib.request.Request(url)
    req.add_header("Authorization", f"Bearer {token}")
    req.add_header("Accept", "application/json")
    with urllib.request.urlopen(req) as resp:
        body = resp.read().decode("utf-8")
        return json.loads(body), resp.headers


def parse_next_link(headers):
    link = headers.get("Link")
    if not link:
        return None
    parts = [p.strip() for p in link.split(",")]
    for p in parts:
        if 'rel="next"' in p:
            lt = p.find("<")
            gt = p.find(">")
            if lt >= 0 and gt > lt:
                return p[lt + 1:gt]
    return None


def paginated_get_all_list_key(url, token, list_key, verbose=False):
    out = []
    cur = url
    while cur:
        if verbose:
            print(f"[GET] {cur}")
        data, headers = http_get_json(cur, token)

        if isinstance(data, dict) and list_key in data and isinstance(data[list_key], list):
            out.extend(data[list_key])
        elif isinstance(data, list):
            out.extend(data)
        else:
            out.append(data)

        cur = parse_next_link(headers)
    return out


def http_post_json(url, token, body):
    """POST JSON to a Canvas API endpoint with Bearer auth.
    Returns (parsed_json, headers).
    """
    payload = json.dumps(body).encode("utf-8")
    req = urllib.request.Request(url, data=payload, method="POST")
    req.add_header("Authorization", f"Bearer {token}")
    req.add_header("Content-Type", "application/json")
    req.add_header("Accept", "application/json")
    with urllib.request.urlopen(req) as resp:
        raw = resp.read().decode("utf-8")
        return json.loads(raw), resp.headers


def http_get_raw(url):
    """GET a URL without auth headers.  Returns raw bytes.
    Used for downloading files whose URL contains a verifier token
    (e.g. Canvas report CSV downloads where sending a Bearer header
    alongside the verifier causes authentication to fail).
    """
    req = urllib.request.Request(url)
    with urllib.request.urlopen(req) as resp:
        return resp.read()


def paginated_get_all(url, token, verbose=False):
    out = []
    cur = url
    while cur:
        if verbose:
            print(f"[GET] {cur}")
        data, headers = http_get_json(cur, token)
        if isinstance(data, list):
            out.extend(data)
        else:
            out.append(data)
        cur = parse_next_link(headers)
    return out
