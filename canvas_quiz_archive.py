#!/usr/bin/env python3
#
# Date: 2026-01-23
# Version: 1.0.1
# Purpose: Export Canvas Classic Quiz submissions (per student) to HTML+JSON and SQLite. Supports offline mode using mock JSON.
# Usage: canvas_quiz_archive.py COURSE_ID QUIZ_ID OUTDIR OUTDB
#        canvas_quiz_archive.py COURSE_ID QUIZ_ID OUTDIR OUTDB --base-url URL --token TOKEN
#        canvas_quiz_archive.py COURSE_ID QUIZ_ID OUTDIR OUTDB --base-url URL --token-file FILE
#        canvas_quiz_archive.py COURSE_ID QUIZ_ID OUTDIR OUTDB --offline --mock-dir DIR
#        canvas_quiz_archive.py --help
# Input: Canvas API access token; or mock JSON files produced from exported SpeedGrader HTML.
# Output: One HTML file per submission + a SQLite database.
# Chat name: Canvas SpeedGrader Archive
# GPT Model: GPT-5.2 Thinking
# Attribution: Generated by Michael Gilchrist in collaboration with ChatGPT.

import argparse
import csv
import datetime as dt
import html
import json
import os
import sqlite3
import sys
import urllib.parse
import urllib.request


def die(msg):
    print(f"Error: {msg}", file=sys.stderr)
    sys.exit(1)


def read_token(token, token_file):
    if token:
        return token.strip()
    if token_file:
        with open(token_file, "r", encoding="utf-8") as f:
            return f.read().strip()
    die("No token provided. Use --token or --token-file (unless --offline).")


def http_get_json(url, token):
    req = urllib.request.Request(url)
    req.add_header("Authorization", f"Bearer {token}")
    req.add_header("Accept", "application/json")
    with urllib.request.urlopen(req) as resp:
        data = resp.read().decode("utf-8")
        return json.loads(data), resp.headers


def parse_next_link(headers):
    link = headers.get("Link")
    if not link:
        return None
    parts = [p.strip() for p in link.split(",")]
    for p in parts:
        if 'rel="next"' in p:
            lt = p.find("<")
            gt = p.find(">")
            if lt >= 0 and gt > lt:
                return p[lt + 1 : gt]
    return None


def paginated_get_all(url, token, verbose=False):
    out = []
    cur = url
    while cur:
        if verbose:
            print(f"[GET] {cur}", file=sys.stderr)
        data, headers = http_get_json(cur, token)
        if isinstance(data, list):
            out.extend(data)
        else:
            out.append(data)
        cur = parse_next_link(headers)
    return out


def ensure_outdir(outdir):
    os.makedirs(outdir, exist_ok=True)


def sanitize_filename(s):
    keep = []
    for ch in str(s):
        if ch.isalnum() or ch in ("-", "_", "."):
            keep.append(ch)
        else:
            keep.append("_")
    return "".join(keep)


def now_utc_iso():
    return dt.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"


def init_db(db_path):
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS submissions (
            submission_id INTEGER PRIMARY KEY,
            student_id INTEGER,
            quiz_id INTEGER,
            quiz_name TEXT,
            time_start TEXT,
            time_end TEXT,
            time_total INTEGER,
            points_total REAL
        )
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS question_records (
            submission_id INTEGER NOT NULL,
            student_id INTEGER,
            quiz_id INTEGER,

            question_id INTEGER NOT NULL,
            question_position INTEGER,
            question_type TEXT,

            question_prompt TEXT,
            question_response_json TEXT,
            question_key TEXT,

            points_possible REAL,
            points_earned REAL,

            PRIMARY KEY (submission_id, question_id)
        )
        """
    )

    conn.commit()
    return conn


def insert_submission(conn, sub):
    cur = conn.cursor()
    cur.execute(
        """
        INSERT OR REPLACE INTO submissions (
            submission_id, student_id, quiz_id, quiz_name,
            time_start, time_end, time_total, points_total
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """,
        (
            sub["submission_id"],
            sub.get("student_id"),
            sub.get("quiz_id"),
            sub.get("quiz_name"),
            sub.get("time_start"),
            sub.get("time_end"),
            sub.get("time_total"),
            sub.get("points_total"),
        ),
    )
    conn.commit()


def insert_question_record(conn, q):
    cur = conn.cursor()
    cur.execute(
        """
        INSERT OR REPLACE INTO question_records (
            submission_id, student_id, quiz_id,
            question_id, question_position, question_type,
            question_prompt, question_response_json, question_key,
            points_possible, points_earned
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """,
        (
            q["submission_id"],
            q.get("student_id"),
            q.get("quiz_id"),
            q["question_id"],
            q.get("question_position"),
            q.get("question_type"),
            q.get("question_prompt"),
            json.dumps(q.get("question_response"), ensure_ascii=True),
            q.get("question_key"),
            q.get("points_possible"),
            q.get("points_earned"),
        ),
    )
    conn.commit()


def build_html(submission, questions):
    def esc(x):
        return html.escape("" if x is None else str(x))

    q_blocks = []
    for q in questions:
        q_blocks.append(
            f"""
    <article class="question"
             submission_id="{esc(q["submission_id"])}"
             student_id="{esc(q.get("student_id"))}"
             quiz_id="{esc(q.get("quiz_id"))}"
             question_id="{esc(q["question_id"])}"
             question_position="{esc(q.get("question_position"))}"
             question_type="{esc(q.get("question_type"))}">
      <h3>Question {esc(q.get("question_position"))}</h3>

      <dl>
        <dt>submission_id</dt><dd>{esc(q["submission_id"])}</dd>
        <dt>student_id</dt><dd>{esc(q.get("student_id"))}</dd>
        <dt>quiz_id</dt><dd>{esc(q.get("quiz_id"))}</dd>
        <dt>question_id</dt><dd>{esc(q["question_id"])}</dd>

        <dt>question_position</dt><dd>{esc(q.get("question_position"))}</dd>
        <dt>question_type</dt><dd>{esc(q.get("question_type"))}</dd>

        <dt>points_possible</dt><dd>{esc(q.get("points_possible"))}</dd>
        <dt>points_earned</dt><dd>{esc(q.get("points_earned"))}</dd>
      </dl>

      <div class="field-label">question_prompt</div>
      <div class="question_prompt">{esc(q.get("question_prompt"))}</div>

      <div class="field-label">question_response</div>
      <pre class="question_response">{html.escape(json.dumps(q.get("question_response"), ensure_ascii=True, indent=2))}</pre>

      <div class="field-label">question_key</div>
      <div class="question_key">{esc(q.get("question_key"))}</div>
    </article>
"""
        )

    archive_obj = {
        "submission": submission,
        "questions": questions,
        "generated_utc": now_utc_iso(),
    }

    sub = submission
    return f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Canvas Quiz Archive - submission_id={esc(sub["submission_id"])}</title>
  <style>
    body {{ font-family: sans-serif; margin: 1.25rem; }}
    h1, h2, h3 {{ margin: 0.5rem 0; }}
    .muted {{ color: #555; }}
    .submission, .question {{ border: 1px solid #ccc; padding: 0.75rem; border-radius: 6px; margin: 0.75rem 0; }}
    dl {{ display: grid; grid-template-columns: 12rem 1fr; gap: 0.25rem 0.75rem; margin: 0; }}
    dt {{ font-weight: bold; }}
    dd {{ margin: 0; }}
    pre {{ white-space: pre-wrap; word-wrap: break-word; margin: 0.5rem 0 0 0; }}
    .field-label {{ font-weight: bold; margin-top: 0.5rem; }}
  </style>
</head>

<body>
  <h1>Canvas Quiz Archive</h1>
  <p class="muted">One file per quiz submission. Visible HTML below; full machine-readable JSON at end.</p>

  <section class="submission"
           submission_id="{esc(sub["submission_id"])}"
           student_id="{esc(sub.get("student_id"))}"
           quiz_id="{esc(sub.get("quiz_id"))}">
    <h2>Submission</h2>
    <dl>
      <dt>submission_id</dt><dd>{esc(sub["submission_id"])}</dd>
      <dt>student_id</dt><dd>{esc(sub.get("student_id"))}</dd>
      <dt>quiz_id</dt><dd>{esc(sub.get("quiz_id"))}</dd>
      <dt>quiz_name</dt><dd>{esc(sub.get("quiz_name"))}</dd>

      <dt>time_start</dt><dd>{esc(sub.get("time_start"))}</dd>
      <dt>time_end</dt><dd>{esc(sub.get("time_end"))}</dd>
      <dt>time_total</dt><dd>{esc(sub.get("time_total"))}</dd>

      <dt>points_total</dt><dd>{esc(sub.get("points_total"))}</dd>
    </dl>
  </section>

  <section class="questions">
    <h2>Questions</h2>
{''.join(q_blocks)}
  </section>

  <script type="application/json" id="canvas_quiz_archive">
{json.dumps(archive_obj, ensure_ascii=True, indent=2)}
  </script>
</body>
</html>
"""


def get_quiz_submissions(base_url, token, course_id, quiz_id, verbose=False):
    url = f"{base_url}/api/v1/courses/{course_id}/quizzes/{quiz_id}/submissions?include[]=quiz"
    return paginated_get_all(url, token, verbose=verbose)


def get_quiz_questions(base_url, token, course_id, quiz_id, verbose=False):
    url = f"{base_url}/api/v1/courses/{course_id}/quizzes/{quiz_id}/questions"
    return paginated_get_all(url, token, verbose=verbose)


def get_submission_questions(base_url, token, submission_id, verbose=False):
    url = f"{base_url}/api/v1/quiz_submissions/{submission_id}/questions?include[]=quiz_question"
    return paginated_get_all(url, token, verbose=verbose)


def build_question_lookup(quiz_questions):
    out = {}
    for qq in quiz_questions:
        qid = qq.get("id")
        if qid is None:
            continue
        out[int(qid)] = {
            "question_id": int(qid),
            "question_position": qq.get("position"),
            "question_type": qq.get("question_type"),
            "question_prompt": qq.get("question_text"),
            "points_possible": qq.get("points_possible"),
            "question_key": qq.get("neutral_comments"),
        }
    return out


def load_json(path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def offline_load_mock(mock_dir, submission_id, verbose=False):
    p_subs = os.path.join(mock_dir, "mock_quiz_submissions.json")
    p_qs = os.path.join(mock_dir, "mock_quiz_questions.json")
    p_sqs = os.path.join(mock_dir, f"mock_quiz_submission_{submission_id}_questions.json")

    if verbose:
        print(f"[OFFLINE] Reading: {p_subs}", file=sys.stderr)
        print(f"[OFFLINE] Reading: {p_qs}", file=sys.stderr)
        print(f"[OFFLINE] Reading: {p_sqs}", file=sys.stderr)

    subs = load_json(p_subs)
    qqs = load_json(p_qs)
    sqs = load_json(p_sqs)
    return subs, qqs, sqs


def main():
    ap = argparse.ArgumentParser(description="Export Canvas Classic Quiz submissions to HTML+JSON and SQLite.")
    ap.add_argument("course_id", type=int)
    ap.add_argument("quiz_id", type=int)
    ap.add_argument("outdir", type=str)
    ap.add_argument("outdb", type=str)

    ap.add_argument("--base-url", type=str, default=None, help="Canvas base URL, e.g. https://utk.instructure.com")
    ap.add_argument("--token", type=str, default=None, help="Canvas API token")
    ap.add_argument("--token-file", type=str, default=None, help="File containing Canvas API token")

    ap.add_argument("--offline", action="store_true", help="Offline mode: read mock JSON instead of calling Canvas API")
    ap.add_argument("--mock-dir", type=str, default=None, help="Directory with mock JSON files")

    ap.add_argument("--dry-run", action="store_true", help="Do not write files or DB")
    ap.add_argument("--verbose", action="store_true", help="Verbose logging")

    args = ap.parse_args()

    ensure_outdir(args.outdir)

    token = None
    if not args.offline:
        if not args.base_url:
            die("--base-url is required unless --offline")
        token = read_token(args.token, args.token_file)
        base_url = args.base_url.rstrip("/")

        if args.verbose:
            print("[INFO] Fetching quiz questions...", file=sys.stderr)
        quiz_questions = get_quiz_questions(base_url, token, args.course_id, args.quiz_id, verbose=args.verbose)

        if args.verbose:
            print("[INFO] Fetching quiz submissions...", file=sys.stderr)
        submissions = get_quiz_submissions(base_url, token, args.course_id, args.quiz_id, verbose=args.verbose)
    else:
        if not args.mock_dir:
            die("--mock-dir is required with --offline")
        # Determine submission_id from the mock submissions file (first element)
        subs = load_json(os.path.join(args.mock_dir, "mock_quiz_submissions.json"))
        if not subs:
            die("mock_quiz_submissions.json is empty")
        submission_id = subs[0].get("id")
        if submission_id is None:
            die("Could not find submission id in mock_quiz_submissions.json")

        submissions, quiz_questions, _ = offline_load_mock(args.mock_dir, submission_id, verbose=args.verbose)

    q_lookup = build_question_lookup(quiz_questions)

    if args.dry_run:
        print(f"[DRY RUN] Would write HTML files to: {args.outdir}", file=sys.stderr)
        print(f"[DRY RUN] Would write SQLite DB to: {args.outdb}", file=sys.stderr)
        print(f"[DRY RUN] Submissions found: {len(submissions)}", file=sys.stderr)
        sys.exit(0)

    conn = init_db(args.outdb)

    n_written = 0
    for sub in submissions:
        submission_id = sub.get("id")
        user_id = sub.get("user_id")
        quiz_id = sub.get("quiz_id")

        if submission_id is None or quiz_id is None:
            continue

        submission_obj = {
            "submission_id": int(submission_id),
            "student_id": int(user_id) if user_id is not None else None,
            "quiz_id": int(quiz_id),
            "quiz_name": (sub.get("quiz") or {}).get("title"),
            "time_start": sub.get("started_at"),
            "time_end": sub.get("finished_at"),
            "time_total": sub.get("time_spent"),
            "points_total": sub.get("score"),
        }

        insert_submission(conn, submission_obj)

        if args.offline:
            _, _, sub_questions = offline_load_mock(args.mock_dir, int(submission_id), verbose=args.verbose)
        else:
            if args.verbose:
                print(f"[INFO] Fetching responses for submission_id={submission_id}", file=sys.stderr)
            sub_questions = get_submission_questions(base_url, token, int(submission_id), verbose=args.verbose)

        question_rows = []
        for sq in sub_questions:
            qq = sq.get("quiz_question") or {}
            qid = qq.get("id")

            if qid is None:
                continue
            qid = int(qid)

            meta = q_lookup.get(qid, {})

            # In offline mocks, we stored:
            #   answer = {"format":"html_fragment","value":"..."}
            # plus optionally earned_points/points_possible
            question_response = sq.get("answer")
            points_earned = sq.get("earned_points")

            qrow = {
                "submission_id": int(submission_id),
                "student_id": int(user_id) if user_id is not None else None,
                "quiz_id": int(quiz_id),

                "question_id": qid,
                "question_position": meta.get("question_position"),
                "question_type": meta.get("question_type"),
                "question_prompt": meta.get("question_prompt"),
                "question_key": meta.get("question_key"),
                "points_possible": meta.get("points_possible"),

                "question_response": question_response,
                "points_earned": points_earned,
            }

            insert_question_record(conn, qrow)
            question_rows.append(qrow)

        fname = f"quiz_{args.quiz_id}_submission_{submission_id}_student_{user_id}.html"
        fname = sanitize_filename(fname)
        outpath = os.path.join(args.outdir, fname)

        html_text = build_html(submission_obj, question_rows)
        with open(outpath, "w", encoding="utf-8") as f:
            f.write(html_text)

        n_written += 1

    if args.verbose:
        print(f"[INFO] Wrote {n_written} HTML files", file=sys.stderr)
        print(f"[INFO] SQLite DB: {args.outdb}", file=sys.stderr)


if __name__ == "__main__":
    main()
